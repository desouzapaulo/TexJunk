\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\title{Boundary Condition Application Using Finite Element Method}
\author{Paulo Henrique Brito de Souza}
\date{\today}

\begin{document}
\maketitle

\newpage
\tableofcontents
\listoffigures
\newpage

\section{Introduction}
This article will explore the application of the finite element method (FEM) to solve boundary value problems involving ***. The article will compare the FEM solution with the analytical solution and discuss the advantages and limitations of each method. It will be presented an example of a beam fixed at one end and subjected to a concentrated load at the free end, and show how to obtain the deflection distribution using both FEM and analytical solutions.

\section{Isis}

\section{The Problem}

%\begin{figure}
%\centering
%\includegraphics[scale=0.5]{figure.jpg}
%\caption{Cantilever beam}
%\label{fig:cantileverbeam}
%\end{figure}

\section{Analytical Solution}
Please note that the following formulas are derived based on the assumptions of small deformations and linear elastic material behaviour. For large deformations or materials with non-linear behaviour, a more complex analysis may be required.

\section{Numerical Solution}

\subsection{Finite Element Method}
The finite element method (FEM) is a numerical technique for solving partial differential equations that arise from various physical and engineering problems. The FEM divides the domain of interest into smaller sub-domains, called finite elements, and approximates the solution by a polynomial function over each element. The FEM can handle complex geometries, boundary conditions, and material properties, and is widely used in fields such as structural mechanics, fluid dynamics, heat transfer, electromagnetic, and more. the polynomial functions used to approximate the results inside an element are called shape functions. They are mathematical expressions that describe the spatial variation of a quantity within an element of a finite element mesh and are used to interpolate the values of the unknowns at the nodes to any point within the element. Shape functions also determine the accuracy and convergence properties of the finite element method, having different forms depending on the type, order and geometry of the element. In this solution will be used a first order polynomial for the shape functions due the simple geometry of the problem.

\subsection{Matlab Code}
This is a MATLAB function named `KFTransform`. It takes three inputs: `Neu` (Neumann vector), `Dir` (Dirichlet vector), and `K` (Global stiffness matrix). The function initializes a zero matrix `k` of the same size as `Dir` and `K`. It then enters a loop over the size of `Dir`. If the `Dir`th index of `Neu` is not zero, it throws an error. Otherwise, it modifies the `k` and `K` matrices. Finally, it calculates `Neumod` by subtracting the product of `k'` and the second column of `Dir` from `Neu`, and assigns `K` to `Kmod`. The function returns `Kmod` and `Neumod`.

\begin{verbatim}
        function [Kmod, Neumod] = KFTransform(Neu, Dir, K)
            k = zeros(size(Dir, 1), size(K, 2));
            for i = 1:size(Dir, 1)
                if Neu(Dir(i, 1)) ~= 0
                    error('Make sure that there are
                    not two types of BC at the same node.')
                end
                k(i, :) = K(Dir(i, 1), :);
                K(Dir(i, 1),:) = 0;
                K(:, Dir(i, 1)) = 0;
                K(Dir(i, 1), Dir(i, 1)) = 1;      
            end
            Neumod = (Neu - k'*Dir(:, 2));
            Kmod = K;
\end{verbatim}

Here's a brief explanation of what each line does:

\begin{description}
\item[]
\item[ - ]`k = zeros(size(Dir, 1), size(K, 2));`: Initializes `k` as a zero matrix with the same number of rows as `Dir` and the same number of columns as `K`.
\item[ - ]`for i = 1:size(Dir, 1)`: Starts a loop that iterates over each row of `Dir`.
\item[ - ]`if Neu(Dir(i, 1)) ~= 0`: Checks if the `Dir(i, 1)`th element of `Neu` is not zero.
\item[ - ]`error('Make sure that there are not two types of BC at the same node.')`: If the above condition is true, it throws an error.
\item[ - ]`k(i, :) = K(Dir(i, 1), :);`: Assigns the `Dir(i, 1)`th row of `K` to the `i`th row of `k`.
\item[ - ]`K(Dir(i, 1),:) = 0;`: Sets the `Dir(i, 1)`th row of `K` to zero.
\item[ - ]`K(:, Dir(i, 1)) = 0;`: Sets the `Dir(i, 1)`th column of `K` to zero.
\item[ - ]`K(Dir(i, 1), Dir(i, 1)) = 1;`: Sets the `Dir(i, 1)`th diagonal element of `K` to one.
\item[ - ]`Neumod = (Neu - k'*Dir(:, 2));`: Calculates `Neumod` by subtracting the product of the transpose of `k` and the second column of `Dir` from `Neu`.
\item[ - ]`Kmod = K;`: Assigns `K` to `Kmod`.
\end{description}

\end{document}
